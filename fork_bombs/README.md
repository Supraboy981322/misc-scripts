# Just because

I may or may not have a mild obsession with fork bombs

--- 

## metrics

<center>Golang <code>int.go</code> <a href="int.go">source code</a></center>
<img alt="int.go ram utilization graph" src="metrics/int.go.png" />

<center>Golang <code>foo.go</code> <a ref="foo.go">source code</a></center>
<img alt="foo.go ram utilization graph" src="metrics/foo.go.png" />

<center>Golang <code>bar.go</code> <a ref="bar.go">source code</a></center>
<img alt="bar.go ram utilization graph" src="metrics/bar.go.png" />

<center>TypeScript <code>ts.ts</code> <a href="ts.ts">source code</a></center>
<img alt="ts.ts ram utilization graph" src="metrics/ts.ts.png" />

<center>TypeScript <code>2.ts</code> <a href="2.ts">source code</a></center>
<img alt="2.ts ram utilization graph" src="metrics/2.ts.png" />

<center>TypeScript <code>3.ts</code> <a href="3.ts">source code</a></center>
<img alt="3.ts ram utilization graph" src="metrics/3.ts.png" />

<center>TypeScript <code>4.ts</code> <a href="4.ts">source code</a></center>
<img alt="4.ts ram utilization graph" src="metrics/4.ts.png" />

I also have a "fork-bomb" written in Zig, but it's not really a fork bomb, because Zig doesn't currently have async, unfortunately. So there is no performance graph for it, as it would take forever to max-out 8GBs of RAM in it's current state. (I might rewrite it when the async Zig update finally comes out to learn the new async)
